#include "hal_data.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

volatile bool uart_send_complete_flag = false;
static uint8_t uart_receive_buffer;

#ifdef __GNUC__
/* With GCC/RAISONANCE, small msg_info (option LD Linker->Libraries->Small msg_info
   set to 'Yes') calls __io_putchar() */
#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#define GETCHAR_PROTOTYPE int __io_getchar(void)
#else
#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#define GETCHAR_PROTOTYPE int fgetc(FILE *f)
#endif /* __GNUC__ */

PUTCHAR_PROTOTYPE
{
    fsp_err_t err = FSP_SUCCESS;
    err = R_SCI_UART_Write(&g_uart_ctrl, (uint8_t *) &ch, 1);
    while(uart_send_complete_flag == false);
    uart_send_complete_flag = false;
    return ch;
}

GETCHAR_PROTOTYPE
{
  uint8_t ch = 0;
  do
  {
      R_SCI_UART_Read(&g_uart_ctrl, (uint8_t *)&ch, 1);
  }while('\0' == ch);
  return ch;


}

int _read (int file, char *ptr, int len)
{
    *ptr = __io_getchar();
    return 1;
}

int _write(int file, char *ptr, int len)
{
    int DataIdx;

    for (DataIdx = 0; DataIdx < len; DataIdx++)
    {
        __io_putchar(*ptr++);
    }
    return len;
}

//void user_uart_callback(uart_callback_args_t *p_args)
//{
//    switch (p_args->event)
//    {
//       case UART_EVENT_RX_CHAR:
//       {
////           GETCHAR_PROTOTYPE;
//           uart_receive_buffer = (uint8_t *)&(p_args->data);
////             R_SCI_UART_Write(&g_uart_ctrl, (uint8_t *)&(p_args->data), 1);
//             break;
//       }
//       case UART_EVENT_TX_COMPLETE:
//       {
//             uart_send_complete_flag = true;
//             break;
//       }
//       default:
//             break;
//    }
//}


/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */

    R_SCI_UART_Open (&g_uart_ctrl, &g_uart_cfg);

//    uint8_t *p_msg = "1234";
//
//    uint8_t msg_len = ((uint8_t)(strlen(p_msg)));
//
//
//    R_SCI_UART_Write (&g_uart_ctrl, p_msg, msg_len);
//
//    R_BSP_SoftwareDelay(100, BSP_DELAY_UNITS_MILLISECONDS);
//    R_SCI_UART_Write (&g_uart_ctrl, "A", 1);

//    printf("1234");
//    puts("1234");

//    putchar('H');
//
//    putchar('\n');
//
//    putchar('I');
//
//    putchar('\n');
//
//    putchar('J');






//    printf("%c", a);

    while(1)
    {

            char a = getchar();

    R_SCI_UART_Write(&g_uart_ctrl, (uint8_t *) &a, 1);

    }


#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
